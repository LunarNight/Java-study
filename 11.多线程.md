###11.1进程与线程
进程:正在执行的程序称作为一个进程.进程负责了内存空间的划分.  
线程:线程在一个进程中负责了代码的执行,就是进程中一个执行路径.  
多线程:一个进程中有多个线程在同时执行不同的任务.  
一个java应用程序至少有两个线程,一个主线程负责执行main方法的代码,一个垃圾回收器线程回收垃圾.  
多线程好处:  
1. 解决了一个进程能同时执行多个任务的问题.  
2. 提高了资源的利用率.  
多线程的弊端:  
1. 增加CPU负担.  
2. 降低了一个进程中线程的执行概率.  
3. 引发了线程安全问题.  
4. 出现了死锁现象.  
如何创建多线程:  
方式一:
1. 自定义一个类继承Thread.  
2. 重写run()方法.  
每个线程都有自己的任务代码.JVM创建的主线程的任务代码就是main方法中的所有代码,  
自定义线程的任务代码就在run方法中,自定义线程负责了run方法中代码.  
3. 创建Thread的子类对象,并且调用start方法开启线程.  
注意:一个线程一旦开启,那么线程就会执行run方法中的代码,run方法不能直接调用,直接调用就相当于调用了一个普通的方法,并没有开启新的线程.  
run()方法父类没有抛出异常类型,子类也不能抛出,只能进行try,catch处理.  
sleep()是个静态方法,哪个线程执行sleep.哪个线程睡眠.要捕获异常.  


```
public class L extends Thread {  //继承Thread
	public void run() {
		for (int i = 0;i<100;i++) { 
			System.out.println("自定义线程执行: "+i);
		}
	}
	public static void  main (String args[]) {
		L l = new L();
		l.start();   //使用start方法创建线程
		for (int i = 0;i<100;i++) { 
			System.out.println("主线程执行: "+i);
		}
	}
}
```
线程的常用方法:  
Thread(String name)  初始化线程的名字  
setName(String name) 设置线程对象名  
getName()            返回线程名字  

sleep()     线程睡眠指定的毫秒数  
getPriority() 返回当前线程优先级,默认是5.  
setPriority(int newPriority) 设置线程的优先级  
currentThread()   返回cpu正在执行的线程的对象,返回Thread类型.  

```
public class L extends Thread {
	public L (String name) {
		super(name);
	}
	public void run() {
		System.out.println("子线程名字:"+this.getName());
		System.out.println("当前线程对象:"+this.currentThread());
	}
	public static void main(String args[]) {
		L l = new L("子线程");
		l.setPriority(7);
		l.start();
		l.setName("哈喽");
		System.out.println("主线程对象:"+Thread.currentThread());
		System.out.println("子线程优先级:"+l.getPriority());
	}
	
}

```
###11.2线程安全问题
出现的原因:  
1. 存在两个或者两个以上的线程对象,而且线程之间共享一个资源.  
2. 有多个语句操作了共享资源.
解决方法:  
方式一:同步代码块.  
同步代码快格式:  
synchronized(锁对象){  
    需要被同步的代码..  
}  
同步代码块要注意事项:  
1. 任意的一个对象都可以作为锁对象.  
2. 在同步代码块中调用了sleep方法并不是释放锁对象的.  
3. 只有真正存在线程安全问题的时候才使用同步代码快.否则会降低效率.  
4. 多线程操作的锁对象必须是唯一共享的.否则无效.  
```
class SaleTicket extends Thread {
	static int num = 20;
	static Object o = new Object();
	public SaleTicket(String name) {
		super(name);
	}
	public void run() {
		while(true) {
			synchronized("锁"){     //字符串是共享的,如果存在就不再创建.   如果换成new String("锁"),就不行
				if(num>0) {
					System.out.println(Thread.currentThread().getName()+"售出了第"+num+"张票");
					num--;
					try {
						Thread.sleep(100);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}else {
				System.out.println(this.getName()+"售空了");
				break;
				}
			}
		}
	}
}

public class L {
	public static void main(String args[]) {
		SaleTicket a = new SaleTicket("一号");
		SaleTicket b = new SaleTicket("二号");
		SaleTicket c = new SaleTicket("三号");
		
		a.start();
		b.start();
		c.start();
	}
}
```

方式二:同步函数:同步函数就是使用synchronized修饰一个函数.  
同步函数需要注意的方面:  
1. 如果是一个非静态同步函数,锁对象是this对象;如果是静态的同步函数,锁对象是当前函数所属的类的字节码文件(class对象)  
2. 同步函数的锁对象是固定的,不能由你来指定.  
